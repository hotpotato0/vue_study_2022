# ES6
간결하고 코딩을 덜 할 수 있는 방법 
시간을 효율적으로 사용할 수 있고, 빠르게 프로토타이핑 할 수 있고 , 빠르게 재개발 할 수 있다

- Const&let
- Arrow Function
- Enhanced Object Literals
- Modules 

(VueX에서)
- Distructuring
- Seperate Operating 


* ES6 란?
ECMAScript 2015와 동일한 용어
2015년은 ES5(2009)년 이래로 진행한 첫 메이저 업데이트가 승인된 해
최신 Front-End Framework인 React, Angular, Vue에서 권고하는 언어 형식
ES5에 비해 문법이 간결해져서 익숙해지면 코딩을 훨씬 편하게 할 수 있음

## Babel
ES6는 모든 브라우저에서 지원되는 언어는 아님
cf) can i use - 브라우저별로 지원되는 문법을 확인할 수 있다
ES6를 babel로 transpiling(컴파일링) 해서 ES5로 변환하여 사용
- ES5는 모든 브라우저에서 호환 가능하기 때문

  ```
  module: {
    loaders: [{
        test: /\.js$/,
        loader: 'babel-loader',
        query: {
            presets: ['es2015']
        }
  
    }]
  },
  ```

  위의 코드는 웹팩에 있는 바벨 로더를 사용한 것

- 그냥 바벨만 쓴다고 하면, 콘솔창에서 쳐서 변환 가능
- https://babeljs/io
- 위의 홈페이지에서 확인 가능


## const & let : 새로운 변수 선언 방식
cf) 기존 자바스크립트 
변수 선언 했는데 다시 선언 가능
값을 아무렇지 않게 다시 할당할 수 있고
호이스팅? 애매모호했다
이런 것들을 미연에 방지하기 위해 만들은 것이 const와 let

- 블록 단위 { }로 변수의 범위가 제한되었음
  cf) 자바스크립트 : 펑션스콥, 함수 안에서만 변수가 제한되고 for문 등 괄호는 변수가 제한되지 않음
- const : 한번 선언한 값에 대해서 변경할 수 있음 (상수 개념)
- let : 한번 선언한 값에 대해서 다시 선언할 수 없음



``` javascript
const a = 10;
a= 20;
==> 오류
var c = 10;
c= 20;
==> c가 20으로 재할당됨

let a = 10;
let a = 20;
==> 오류 : 이미 a는 할당되어 있음
a = 20;
==> 재할당은 가능
```

## ES5 특징 2가지 리뷰

ES5의 특징 : 변수의 Scope
기존 자바스크립트(ES5)는 { }에 상관없이 스코프가 설정됨

```javascript
var sum = 0;
for (var i = 1; i <= 5; i++){
  sum = sum + 1;
}
console.log(sum); //15
console.log(i); //6
==> 기타 언어에서는 i에 접근할 수 없음
==> ES5에서는 i가 전역변수처럼 잡히게 됨
```

## Hoisting
선언한 함수와 변수를 해석기가 가장 상단에 있는 것처러 인식한다
js 해석기는 코드의 라인 순서와 관계 없이 함수선언식과 변수를 위한 메모리 공간을 먼저 확보한다.
따라서, Function a()와 var는 코드의 최상단으로 끌어 올려진 것(hoisted) 처럼 보인다

``` javascript
function willBeOveriden() {
  return 10;
}
willBeOveriden(); //5
==> 뒤에서 willBeOveriden을 다시 선언했기 때문에 5를 return 하게 됨
function willBeOveriden() {
  return 5;
}'''

''' var sum = 5;
sum = sum + i
function summAllNumbers() {
  /// .. 
}
var i  = 10;

==> sum을 읽어보면 15를 뱉는다
==> i 가 뒤에 있는데도 위에서 오류를 뱉지 않는다
'''
=> ES5에서 읽는 방식
//#1 - 함수 선언식과 변수 선언을 hoisting
var sum;
function summAllNumbers() {

}
var i ;
//#2 - 변수 대입 및 할당
sum = 5;
sum = sum + i;
i = 10;
```



## ES6

{ } 단위로 변수의 범위가 제한됨

``` javascript
let sum = 0;
for (let i = 1; i <= 5; i ++ ){
  sum = sum + i;
}
console.log(sum); // 10
console.log(i); // Uncaught ReferenceError : i is not defined
==> let으로 선언하게 되면 변수 괄호 안에서 변수가 제한되어서 밖으로 나올 수 없음(i)
```

const 로 지정한 값 변경 불가능

``` javascript
const a = 10;
a = 20 ;  // Uncaught TypeError : Assignment to constant variable
하지만, 객체나 배열의 내부는 변경할 수 있다
프로퍼티나 인덱스 조절을 통해서 내용을 바꿀 수 있다
const a = { };
a.num = 10;
console.log(a); // {num : 10}
const a = [];
a.push(20);
console.log(a); // [20]

function f() {
  {
      let x;
      {
          // 새로운 블록안에 새로운 x의 스코프가 생김
          const x = 'sneaky';
          x = foo;// 위에 이미 const로 x를 선언했으므로 다시 값을 대입하면 에러 발생
      }
      // 이전 블록 범위로 돌아왔기 때문에 'let x'에 해당하는 메모리에 값을 대입
      x = 'bar';
      let x = 'inner'; // Uncaught SyntaxError : Identifier 'x' has already been declared
  }
}
```


